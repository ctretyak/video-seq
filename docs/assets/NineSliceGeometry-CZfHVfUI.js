import{V as k,G as f,d as h,v as o,a as U,B as g,b as d}from"./index-CU2cXWwI.js";class p extends k{constructor(t){t instanceof f&&(t={context:t});const{context:e,roundPixels:i,...s}=t||{};super({label:"Graphics",...s}),this.renderPipeId="graphics",e?this._context=e:this._context=this._ownedContext=new f,this._context.on("update",this.onViewUpdate,this),this.allowChildren=!1,this.roundPixels=i??!1}set context(t){t!==this._context&&(this._context.off("update",this.onViewUpdate,this),this._context=t,this._context.on("update",this.onViewUpdate,this),this.onViewUpdate())}get context(){return this._context}get bounds(){return this._context.bounds}addBounds(t){t.addBounds(this._context.bounds)}containsPoint(t){return this._context.containsPoint(t)}onViewUpdate(){if(this._didViewChangeTick++,this._didGraphicsUpdate=!0,this.didViewUpdate)return;this.didViewUpdate=!0;const t=this.renderGroup||this.parentRenderGroup;t&&t.onChildViewUpdate(this)}destroy(t){this._ownedContext&&!t?this._ownedContext.destroy(t):(t===!0||(t==null?void 0:t.context)===!0)&&this._context.destroy(t),this._ownedContext=null,this._context=null,super.destroy(t)}_callContextMethod(t,e){return this.context[t](...e),this}setFillStyle(...t){return this._callContextMethod("setFillStyle",t)}setStrokeStyle(...t){return this._callContextMethod("setStrokeStyle",t)}fill(...t){return this._callContextMethod("fill",t)}stroke(...t){return this._callContextMethod("stroke",t)}texture(...t){return this._callContextMethod("texture",t)}beginPath(){return this._callContextMethod("beginPath",[])}cut(){return this._callContextMethod("cut",[])}arc(...t){return this._callContextMethod("arc",t)}arcTo(...t){return this._callContextMethod("arcTo",t)}arcToSvg(...t){return this._callContextMethod("arcToSvg",t)}bezierCurveTo(...t){return this._callContextMethod("bezierCurveTo",t)}closePath(){return this._callContextMethod("closePath",[])}ellipse(...t){return this._callContextMethod("ellipse",t)}circle(...t){return this._callContextMethod("circle",t)}path(...t){return this._callContextMethod("path",t)}lineTo(...t){return this._callContextMethod("lineTo",t)}moveTo(...t){return this._callContextMethod("moveTo",t)}quadraticCurveTo(...t){return this._callContextMethod("quadraticCurveTo",t)}rect(...t){return this._callContextMethod("rect",t)}roundRect(...t){return this._callContextMethod("roundRect",t)}poly(...t){return this._callContextMethod("poly",t)}regularPoly(...t){return this._callContextMethod("regularPoly",t)}roundPoly(...t){return this._callContextMethod("roundPoly",t)}roundShape(...t){return this._callContextMethod("roundShape",t)}filletRect(...t){return this._callContextMethod("filletRect",t)}chamferRect(...t){return this._callContextMethod("chamferRect",t)}star(...t){return this._callContextMethod("star",t)}svg(...t){return this._callContextMethod("svg",t)}restore(...t){return this._callContextMethod("restore",t)}save(){return this._callContextMethod("save",[])}getTransform(){return this.context.getTransform()}resetTransform(){return this._callContextMethod("resetTransform",[])}rotateTransform(...t){return this._callContextMethod("rotate",t)}scaleTransform(...t){return this._callContextMethod("scale",t)}setTransform(...t){return this._callContextMethod("setTransform",t)}transform(...t){return this._callContextMethod("transform",t)}translateTransform(...t){return this._callContextMethod("translate",t)}clear(){return this._callContextMethod("clear",[])}get fillStyle(){return this._context.fillStyle}set fillStyle(t){this._context.fillStyle=t}get strokeStyle(){return this._context.strokeStyle}set strokeStyle(t){this._context.strokeStyle=t}clone(t=!1){return t?new p(this._context.clone()):(this._ownedContext=null,new p(this._context))}lineStyle(t,e,i){h(o,"Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");const s={};return t&&(s.width=t),e&&(s.color=e),i&&(s.alpha=i),this.context.strokeStyle=s,this}beginFill(t,e){h(o,"Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");const i={};return t&&(i.color=t),e&&(i.alpha=e),this.context.fillStyle=i,this}endFill(){h(o,"Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."),this.context.fill();const t=this.context.strokeStyle;return(t.width!==f.defaultStrokeStyle.width||t.color!==f.defaultStrokeStyle.color||t.alpha!==f.defaultStrokeStyle.alpha)&&this.context.stroke(),this}drawCircle(...t){return h(o,"Graphics#drawCircle has been renamed to Graphics#circle"),this._callContextMethod("circle",t)}drawEllipse(...t){return h(o,"Graphics#drawEllipse has been renamed to Graphics#ellipse"),this._callContextMethod("ellipse",t)}drawPolygon(...t){return h(o,"Graphics#drawPolygon has been renamed to Graphics#poly"),this._callContextMethod("poly",t)}drawRect(...t){return h(o,"Graphics#drawRect has been renamed to Graphics#rect"),this._callContextMethod("rect",t)}drawRoundedRect(...t){return h(o,"Graphics#drawRoundedRect has been renamed to Graphics#roundRect"),this._callContextMethod("roundRect",t)}drawStar(...t){return h(o,"Graphics#drawStar has been renamed to Graphics#star"),this._callContextMethod("star",t)}}const C=class v extends U{constructor(...t){let e=t[0]??{};e instanceof Float32Array&&(h(o,"use new MeshGeometry({ positions, uvs, indices }) instead"),e={positions:e,uvs:t[1],indices:t[2]}),e={...v.defaultOptions,...e};const i=e.positions||new Float32Array([0,0,1,0,1,1,0,1]),s=e.uvs||new Float32Array([0,0,1,0,1,1,0,1]),c=e.indices||new Uint32Array([0,1,2,0,2,3]),r=e.shrinkBuffersToFit,u=new g({data:i,label:"attribute-mesh-positions",shrinkToFit:r,usage:d.VERTEX|d.COPY_DST}),_=new g({data:s,label:"attribute-mesh-uvs",shrinkToFit:r,usage:d.VERTEX|d.COPY_DST}),x=new g({data:c,label:"index-mesh-buffer",shrinkToFit:r,usage:d.INDEX|d.COPY_DST});super({attributes:{aPosition:{buffer:u,format:"float32x2",stride:2*4,offset:0},aUV:{buffer:_,format:"float32x2",stride:2*4,offset:0}},indexBuffer:x,topology:e.topology}),this.batchMode="auto"}get positions(){return this.attributes.aPosition.buffer.data}set positions(t){this.attributes.aPosition.buffer.data=t}get uvs(){return this.attributes.aUV.buffer.data}set uvs(t){this.attributes.aUV.buffer.data=t}get indices(){return this.indexBuffer.data}set indices(t){this.indexBuffer.data=t}};C.defaultOptions={topology:"triangle-list",shrinkBuffersToFit:!1};let H=C;const M=class b extends H{constructor(...t){super({});let e=t[0]??{};typeof e=="number"&&(h(o,"PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead"),e={width:e,height:t[1],verticesX:t[2],verticesY:t[3]}),this.build(e)}build(t){t={...b.defaultOptions,...t},this.verticesX=this.verticesX??t.verticesX,this.verticesY=this.verticesY??t.verticesY,this.width=this.width??t.width,this.height=this.height??t.height;const e=this.verticesX*this.verticesY,i=[],s=[],c=[],r=this.verticesX-1,u=this.verticesY-1,_=this.width/r,x=this.height/u;for(let n=0;n<e;n++){const l=n%this.verticesX,a=n/this.verticesX|0;i.push(l*_,a*x),s.push(l/r,a/u)}const G=r*u;for(let n=0;n<G;n++){const l=n%r,a=n/r|0,T=a*this.verticesX+l,y=a*this.verticesX+l+1,w=(a+1)*this.verticesX+l,P=(a+1)*this.verticesX+l+1;c.push(T,y,w,y,P,w)}this.buffers[0].data=new Float32Array(i),this.buffers[1].data=new Float32Array(s),this.indexBuffer.data=new Uint32Array(c),this.buffers[0].update(),this.buffers[1].update(),this.indexBuffer.update()}};M.defaultOptions={width:100,height:100,verticesX:10,verticesY:10};let W=M;const m=class S extends W{constructor(t={}){t={...S.defaultOptions,...t},super({width:t.width,height:t.height,verticesX:4,verticesY:4}),this.update(t)}update(t){this.width=t.width??this.width,this.height=t.height??this.height,this._originalWidth=t.originalWidth??this._originalWidth,this._originalHeight=t.originalHeight??this._originalHeight,this._leftWidth=t.leftWidth??this._leftWidth,this._rightWidth=t.rightWidth??this._rightWidth,this._topHeight=t.topHeight??this._topHeight,this._bottomHeight=t.bottomHeight??this._bottomHeight,this.updateUvs(),this.updatePositions()}updatePositions(){const t=this.positions,e=this._leftWidth+this._rightWidth,i=this.width>e?1:this.width/e,s=this._topHeight+this._bottomHeight,c=this.height>s?1:this.height/s,r=Math.min(i,c);t[9]=t[11]=t[13]=t[15]=this._topHeight*r,t[17]=t[19]=t[21]=t[23]=this.height-this._bottomHeight*r,t[25]=t[27]=t[29]=t[31]=this.height,t[2]=t[10]=t[18]=t[26]=this._leftWidth*r,t[4]=t[12]=t[20]=t[28]=this.width-this._rightWidth*r,t[6]=t[14]=t[22]=t[30]=this.width,this.getBuffer("aPosition").update()}updateUvs(){const t=this.uvs;t[0]=t[8]=t[16]=t[24]=0,t[1]=t[3]=t[5]=t[7]=0,t[6]=t[14]=t[22]=t[30]=1,t[25]=t[27]=t[29]=t[31]=1;const e=1/this._originalWidth,i=1/this._originalHeight;t[2]=t[10]=t[18]=t[26]=e*this._leftWidth,t[9]=t[11]=t[13]=t[15]=i*this._topHeight,t[4]=t[12]=t[20]=t[28]=1-e*this._rightWidth,t[17]=t[19]=t[21]=t[23]=1-i*this._bottomHeight,this.getBuffer("aUV").update()}};m.defaultOptions={width:100,height:100,leftWidth:10,topHeight:10,rightWidth:10,bottomHeight:10,originalWidth:100,originalHeight:100};let R=m;export{p as G,H as M,R as N};
